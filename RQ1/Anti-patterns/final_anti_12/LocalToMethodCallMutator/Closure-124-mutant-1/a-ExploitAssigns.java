/*   0*/package com.google.javascript.jscomp;
/*   0*/
/*   0*/import com.google.common.base.Preconditions;
/*   0*/import com.google.javascript.rhino.Node;
/*   0*/
/*   0*/class ExploitAssigns extends AbstractPeepholeOptimization {
/*   0*/  Node optimizeSubtree(Node subtree) {
/*  33*/    for (Node child = subtree.getFirstChild(); child != null; ) {
/*  34*/      Node next = child.getNext();
/*  35*/      if (NodeUtil.isExprAssign(child))
/*  36*/        collapseAssign(child.getFirstChild(), child, subtree); 
/*  38*/      child = next;
/*   0*/    } 
/*  40*/    return subtree;
/*   0*/  }
/*   0*/  
/*   0*/  private void collapseAssign(Node assign, Node expr, Node exprParent) {
/*  48*/    Node leftValue = assign.getFirstChild();
/*  49*/    Node rightValue = leftValue.getNext();
/*  50*/    if (isCollapsibleValue(leftValue, true) && collapseAssignEqualTo(expr, exprParent, leftValue)) {
/*  52*/      reportCodeChange();
/*  53*/    } else if (isCollapsibleValue(rightValue, false) && collapseAssignEqualTo(expr, exprParent, rightValue)) {
/*  55*/      reportCodeChange();
/*  56*/    } else if (rightValue.isAssign()) {
/*  58*/      collapseAssign(rightValue, expr, exprParent);
/*   0*/    } 
/*   0*/  }
/*   0*/  
/*   0*/  private static boolean isCollapsibleValue(Node value, boolean isLValue) {
/*  77*/    switch (value.getType()) {
/*   0*/      case 33:
/*  83*/        return (!isLValue || value.getFirstChild().isThis());
/*   0*/      case 38:
/*  86*/        return true;
/*   0*/    } 
/*  89*/    return NodeUtil.isImmutableValue(value);
/*   0*/  }
/*   0*/  
/*   0*/  private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {
/* 110*/    Node assign = expr.getFirstChild();
/* 111*/    Node parent = exprParent;
/* 112*/    Node next = expr.getNext();
/* 113*/    while (next != null) {
/*   0*/      Node leftSide;
/* 114*/      switch (next.getType()) {
/*   0*/        case 4:
/*   0*/        case 98:
/*   0*/        case 100:
/*   0*/        case 101:
/*   0*/        case 108:
/*   0*/        case 130:
/* 122*/          parent = next;
/* 123*/          next = next.getFirstChild();
/*   0*/          continue;
/*   0*/        case 118:
/* 127*/          if (next.getFirstChild().hasChildren()) {
/* 128*/            parent = next.getFirstChild();
/* 129*/            next = parent.getFirstChild();
/*   0*/            continue;
/*   0*/          } 
/* 132*/          return false;
/*   0*/        case 33:
/*   0*/        case 38:
/* 136*/          if (next.isQualifiedName()) {
/* 137*/            String nextName = next.getQualifiedName();
/* 138*/            if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {
/* 145*/              if (!isSafeReplacement(next, assign))
/* 146*/                return false; 
/* 149*/              exprParent.removeChild(expr);
/* 150*/              expr.removeChild(assign);
/* 151*/              parent.replaceChild(next, assign);
/* 152*/              return true;
/*   0*/            } 
/*   0*/          } 
/* 155*/          return false;
/*   0*/        case 86:
/* 170*/          leftSide = next.getFirstChild();
/* 171*/          if (leftSide.isName() || (leftSide.isGetProp() && leftSide.getFirstChild().isThis())) {
/* 175*/            parent = next;
/* 176*/            next = leftSide.getNext();
/*   0*/            continue;
/*   0*/          } 
/* 179*/          return false;
/*   0*/      } 
/* 183*/      if (NodeUtil.isImmutableValue(next) && next.isEquivalentTo(value)) {
/* 188*/        exprParent.removeChild(expr);
/* 189*/        expr.removeChild(assign);
/* 190*/        parent.replaceChild(next, assign);
/* 191*/        return true;
/*   0*/      } 
/* 194*/      return false;
/*   0*/    } 
/* 198*/    return false;
/*   0*/  }
/*   0*/  
/*   0*/  private boolean isSafeReplacement(Node node, Node replacement) {
/* 208*/    if (node.isName())
/* 209*/      return true; 
/* 211*/    Preconditions.checkArgument(node.isGetProp());
/* 213*/    node = node.getFirstChild();
/* 214*/    if (node.isName() && isNameAssignedTo(node.getString(), replacement))
/* 216*/      return false; 
/* 219*/    return true;
/*   0*/  }
/*   0*/  
/*   0*/  private boolean isNameAssignedTo(String name, Node node) {
/* 227*/    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
/* 228*/      if (isNameAssignedTo(name, c))
/* 229*/        return true; 
/*   0*/    } 
/* 233*/    if (node.isName()) {
/* 234*/      Node parent = node.getParent();
/* 235*/      if (parent.isAssign() && parent.getFirstChild() == node && 
/* 236*/        name.equals(node.getString()))
/* 237*/        return true; 
/*   0*/    } 
/* 242*/    return false;
/*   0*/  }
/*   0*/}
